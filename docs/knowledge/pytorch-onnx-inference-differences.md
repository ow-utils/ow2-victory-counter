# PyTorchとONNX Runtimeの推論結果の違いについて

## 概要

同じ学習済みモデルを使用しても、PyTorchとONNX Runtimeでは推論結果が**完全には一致しない**のは正常な挙動です。このドキュメントでは、その理由と実用上の考慮事項をまとめます。

## なぜ完全一致しないのか

### 1. フレームワークの実装差

PyTorchとONNX Runtimeは、異なる実装を持つ別々のフレームワークです：

| 項目 | PyTorch | ONNX Runtime |
|------|---------|--------------|
| 実装言語 | Python (C++バックエンド) | C++ |
| 演算ライブラリ | ATen (PyTorch独自) | 最適化された汎用演算 |
| 目的 | 学習 + 推論 | 推論に特化 |
| 最適化 | 学習を考慮 | 推論速度を優先 |

同じアルゴリズム（例: 畳み込み演算）でも、内部実装が異なるため、数値的に微妙な差が生じます。

### 2. 浮動小数点演算の誤差

CPUでのfloat32演算は、以下の理由で決定的ではありません：

```python
# 理論上は同じだが、実際には異なる結果になる
result1 = (a + b) + c
result2 = a + (b + c)
```

- **演算順序**: フレームワークごとに演算の順序が異なる
- **丸め誤差**: float32の有効桁数（約7桁）による誤差の蓄積
- **並列処理**: GPU/マルチスレッドでの演算順序の非決定性

### 3. 最適化による変換

ONNXへの変換時に、以下のような最適化が適用されます：

- **演算融合**: 複数の演算を1つにまとめる（Conv + BatchNorm + ReLU → 単一演算）
- **定数畳み込み**: コンパイル時に計算可能な部分を事前計算
- **演算順序の変更**: 数学的に等価だが、より効率的な順序に変更

これらの最適化により高速化されますが、数値が微妙に変わります。

### 4. 前処理の実装差

画像前処理でも差が生じる可能性があります：

```python
# Python (OpenCV)
resized = cv2.resize(image, (width, height), interpolation=cv2.INTER_LINEAR)

# Rust (image crate)
resized = image.resize_exact(width, height, FilterType::Triangle)
```

リサイズアルゴリズムの実装が異なるため、ピクセル値が微妙に変わります。

## 実用上の考慮事項

### 許容範囲の判断基準

機械学習の実運用では、以下の基準で判断します：

| 差異 | 評価 | 対応 |
|------|------|------|
| < 1% | 非常に良好 | 問題なし |
| 1-5% | 良好 | 予測クラスが一致していれば問題なし |
| 5-10% | 注意 | 予測クラスが異なる場合は要調査 |
| > 10% | 問題あり | 実装に誤りがある可能性 |

**重要なのは**:
- ✅ 予測クラス（最も確率が高いクラス）が一致しているか
- ✅ 信頼度が実用的な範囲（閾値を超えているか）
- ❌ 小数点以下の完全一致（通常不要）

### 本プロジェクトでの調査結果

2025年1月22日に実施した比較調査の結果：

| 指標 | 値 | 評価 |
|------|---|------|
| テスト画像数 | 10枚 | - |
| 予測一致率 | 100% | ✅ 優秀 |
| 平均信頼度差 | 0.48% | ✅ 非常に良好 |
| 最大差異 | 2.82% | ✅ 良好 |
| 最小差異 | 0.0009% | ✅ ほぼ完全一致 |

#### クラス別の傾向

```
defeat_progressbar: Rustが平均2.15%高い
  └─ 正しいクラスを予測できているため問題なし

その他のクラス: 平均0.1%以下の差
  └─ ほぼ完全に一致
```

#### 結論

✅ **PyTorchからONNXへの変換は成功**
- モデルの精度は保たれている
- 前処理パイプラインは正しく実装されている
- 実運用に問題なし

## 完全一致が必要な場合の対策

もし推論結果の**完全一致**が必要な場合（通常は不要）：

### 方法1: 同じフレームワークを使用

```bash
# 両方でPyTorchを使用
python inference_pytorch.py
python inference_pytorch.py  # 同じ環境なら一致
```

### 方法2: 決定的モードの有効化

```python
# PyTorchで決定的動作を強制
torch.use_deterministic_algorithms(True)
torch.backends.cudnn.deterministic = True
torch.backends.cudnn.benchmark = False
```

ただし、**性能が低下**するため推奨されません。

### 方法3: 同じハードウェア・環境

- 同じCPU/GPU
- 同じOSとドライバー
- 同じライブラリバージョン

完全一致のためのコストは高く、実用上のメリットは少ないです。

## よくある質問

### Q1: 信頼度が1-2%違うのは問題？

**A**: いいえ、正常です。予測クラスが一致していれば問題ありません。

### Q2: ONNXの方が精度が高い/低いことがある？

**A**: どちらもあり得ます。最適化により精度が向上する場合も、わずかに低下する場合もあります。重要なのは、実用上の性能（予測クラスの一致率）です。

### Q3: 時間経過で結果が変わることはある？

**A**: 同じ入力・同じモデルなら、基本的に同じ結果になります。ただし、ハードウェアの温度変化などで極めて微小な差が出る可能性はあります。

### Q4: GPU vs CPU で結果は変わる？

**A**: はい、変わる可能性があります。GPUとCPUでは演算の実装が異なるため、1-5%程度の差が出ることがあります。

## 参考資料

### 関連ドキュメント

- [ONNX変換スクリプト](../../packages/obs-victory-counter/victory-detector/scripts/convert_to_onnx.py)
- [推論比較調査計画](../../packages/ow2-victory-counter-rs/docs/plans/inference-comparison-investigation.md)
- [ONNXファイル形式](./onnx-file-formats.md)

### 外部リソース

- [ONNX公式: Precision and Recall](https://onnx.ai/onnx/intro/converters.html)
- [PyTorch: Reproducibility](https://pytorch.org/docs/stable/notes/randomness.html)
- [浮動小数点演算の基礎](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)

## まとめ

- ✅ **PyTorchとONNXで推論結果が完全一致しないのは正常**
- ✅ **重要なのは予測クラスの一致と信頼度の範囲**
- ✅ **1-5%の差は許容範囲内**
- ✅ **完全一致は通常不要（コストが高い）**
- ✅ **本プロジェクトのONNX実装は成功**

---

**作成日**: 2025-01-22
**最終更新日**: 2025-01-22
**関連調査**: [推論比較調査](../../packages/ow2-victory-counter-rs/docs/plans/inference-comparison-investigation.md)
