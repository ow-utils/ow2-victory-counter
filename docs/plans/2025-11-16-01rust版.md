オーバーウォッチ2をOBSで配信している際に、リアルタイムに勝敗判定を行い画面表示に反映するソフトウェアを実装します。

PoCとして、Pythonで実装を行い試してみた結果、概ねやりたいことが実現できることがわかりました。
このPoCは、 `packages/obs-victory-counter` ディレクトリーにあります。

今回は、必要な機能を整理し、rustで実装しなおしていきます。
rustで実装する理由は以下になります:

- PythonやNodeで実行するプログラムだと、エンドユーザーが実行環境をセットアップする必要が出てしまう
- ゲームのバックグランドで動作させるので、なるべく軽量であるのが望ましい

今回実装するソフトウェア構成は次のようなものを考えています:

- OBSプラグイン
  - オーバーウォッチ2プレイ画面を取得するプラグイン
  - Rustで実装
  - PoCではWebSocket経由で取得していたが、その方式より軽量、低レイテンシーでの処理が期待できる
- 実行ファイル
  - Rustで実装
  - Webサーバー兼画像判定機能を持つ
  - Webサーバー機能
    - 勝敗カウントを管理し、勝敗数を応答する
    - ブラウザーへリアルタイムに勝敗数を通知する
      - WebSocketが向いている？
    - フロントはCDN版Vue。理由は後述
  - 画像判定機能
    - 前述OBSプラグインを経由してゲーム画面を取得する
    - 事前に学習したパターンと比較し勝利化敗北を判定する
      - ロジックはPoCで検証したものと同じ
- 学習プログラム
  - PoCで実装したものと同じ。ただしrustで実装する

エンドユーザーに配布するファイルは次のようなものを考えています:

- OBSプラグイン
- Rust実行ファイル
- 画面レイアウト用設定ファイル
  - CSSやコンフィグ
  - エンドユーザーのスキルによっては、フロントエンドファイル直接編集でレイアウト編集も可能にする
    - なので、CDN版Vueが適しているのではと考えた

検討したいこと:

- 前述の「OBSプラグイン」と「実行ファイル」は1バイナリーにまとめることは可能？可能だとしてそうすべき？

---

## PoCコードの分析結果

既存のPython PoCコードを調査した結果、以下の構造が明らかになりました：

### アーキテクチャ

- **コード量**: 約1,300行（コア実装のみ）
- **主要コンポーネント**:
  - `StateManager` (337行): イベントログ管理、2段階クールダウン、連続検知
  - `VictoryPredictor` (179行): CNN推論、画像前処理パイプライン
  - HTTP APIサーバー (505行): `/state`, `/history`, `/adjust`, `/overlay`エンドポイント

### 重要な機能

1. **2段階クールダウン**:

   - READY → (勝敗検知) → COOLDOWN (180秒) → WAITING_FOR_NONE (none 50回連続) → READY
   - 重複カウント防止と放置時の誤検知防止

2. **連続検知**:

   - デフォルト2回連続で同じ結果を検知したらカウント確定
   - 0.25秒間隔 × 2回 = 0.5秒で判定完了

3. **イベントソーシング**:

   - すべてのイベントをJSONL形式で永続化
   - プロセス再起動後も状態復元可能

4. **OBS連携**:

   - obs-websocket経由でスクリーンショット取得
   - Base64エンコード/デコード

5. **CNN推論**:
   - クロップ領域: `(460, 378, 995, 550)`
   - マスク機能: `(0, 534, 1920, 295)` - 画面下部を黒塗り
   - 5クラス分類: victory_text, victory_progressbar, defeat_text, defeat_progressbar, none

### 依存ライブラリ

| ライブラリ    | 用途          | Rust代替候補              |
| ------------- | ------------- | ------------------------- |
| numpy         | 配列操作      | ndarray                   |
| opencv-python | 画像処理      | opencv-rust               |
| torch         | CNN推論       | tch-rs または onnxruntime |
| obsws-python  | OBS WebSocket | obws                      |
| http.server   | HTTP API      | axum または actix-web     |

---

## 設計上の選択肢の比較

### 1. OBSプラグイン vs 実行ファイルの構成

#### オプションA: 1つのバイナリにまとめる（OBSプラグイン）

**実現可能性**: ✅ 可能（Rustで C FFI を使用）

**メリット**:

- ✅ 配布ファイルが1つで済む
- ✅ ユーザーのセットアップが簡単
- ✅ OBS内部メモリから直接画像取得可能（最速）

**デメリット**:

- ❌ OBSプロセスのクラッシュリスク
- ❌ OBSのプラグインAPIの制約（Tokioランタイムとの相性問題の可能性）
- ❌ デバッグが困難
- ❌ プラグイン開発の複雑さ

#### オプションB: 2つのバイナリに分離 ⭐推奨

**実現可能性**: ✅ 可能（PoCと同様のアーキテクチャ）

**メリット**:

- ✅ 各コンポーネントが独立して動作（安定性向上）
- ✅ 実行ファイル側は通常のRustアプリ開発（デバッグ容易）
- ✅ OBSクラッシュのリスクゼロ
- ✅ 段階的な開発・テストが可能

**デメリット**:

- ❌ obs-websocket経由でのオーバーヘッド（Base64エンコード）
- ❌ 配布ファイルが2つ
- ❌ ユーザーが2つのプロセスを管理する必要

**推奨理由**: 安定性とデバッグ容易さを優先。obs-websocketのオーバーヘッドは0.25秒間隔なら許容範囲。

#### オプションC: OBSプラグインなし（obs-websocket継続）

**実現可能性**: ✅ 可能（PoCそのまま）

**メリット**:

- ✅ 最もシンプル（プラグイン開発不要）
- ✅ PoCで実証済み

**デメリット**:

- ❌ ドキュメントの要件「OBSプラグイン」を満たさない
- ❌ レイテンシー改善が限定的

---

### 2. CNNモデルのRust移植方法

#### オプションA: ONNX形式に変換 ⭐推奨

**メリット**:

- ✅ クロスプラットフォーム性が高い
- ✅ 依存ライブラリが軽量（`onnxruntime-rs`のみ）
- ✅ CPU/GPU両対応
- ✅ モデル最適化の恩恵

**デメリット**:

- ❌ PyTorchからONNXへの変換作業が必要（`torch.onnx.export`）
- ❌ 変換時にサポートされないオペレーションがある可能性

**推奨理由**: 配布の簡便さとクロスプラットフォーム性。変換作業は一度きり。

#### オプションB: tch-rs（PyTorchバインディング）

**メリット**:

- ✅ 既存の`.pth`ファイルをそのまま使用可能
- ✅ 変換作業不要

**デメリット**:

- ❌ libtorchのインストールが必要（配布サイズ増大: 数百MB）
- ❌ バイナリ配布が複雑
- ❌ クロスコンパイルが困難

#### オプションC: Rustネイティブ（burn/candle）

**メリット**:

- ✅ 完全なRust実装（依存が最小）
- ✅ バイナリサイズが最小

**デメリット**:

- ❌ 学習済み重みの移行作業が必要
- ❌ モデルをRustで再実装する必要
- ❌ 学習プログラムもRustで書き直す必要

---

### 3. ブラウザへのリアルタイム通知方法

#### オプションA: WebSocket

**メリット**:

- ✅ 真の双方向通信
- ✅ 最低レイテンシー

**デメリット**:

- ❌ 実装がやや複雑（接続管理、再接続ロジック）
- ❌ PoCより複雑化

#### オプションB: Server-Sent Events (SSE) ⭐推奨

**メリット**:

- ✅ サーバー→ブラウザのプッシュ通知が可能
- ✅ HTTP/2との相性が良い
- ✅ 自動再接続機能（ブラウザ標準）
- ✅ WebSocketより実装が簡単

**デメリット**:

- ❌ 一方向通信のみ（サーバー→ブラウザ）

**補正リクエストについて**: ✅ 可能

- SSEはサーバー→ブラウザの通知専用
- ブラウザ→サーバーの補正リクエストは通常のHTTP POST `/adjust`で実装
- PoCと同じAPI設計が可能

**推奨理由**: リアルタイム性とシンプルさのバランス。補正リクエストは通常のPOSTで実現可能。

#### オプションC: ポーリング（PoCと同様）

**メリット**:

- ✅ 実装が最もシンプル
- ✅ PoCで実証済み

**デメリット**:

- ❌ 5秒間隔の遅延
- ❌ リアルタイム性が低い

---

### 4. フロントエンド配置方法

#### 推奨アプローチ: ハイブリッド方式

**HTML/JS（Vue CDN）**: バイナリに組み込み

- `include_str!("../frontend/index.html")` で組み込み
- ユーザーが誤って壊すことがない

**CSS**: 別ファイルとして配布

- `frontend/style.css` として配布
- ユーザーがカスタマイズ可能

**ディレクトリ構成**:

```
victory-detector/
├── victory-detector.exe (または .so)
└── frontend/
    ├── style.css      # ユーザーがカスタマイズ可能
    └── config.json    # 表示設定（オプション）
```

**実装**:

- HTMLは`/overlay`エンドポイントで組み込み版を返す
- CSSは`GET /frontend/style.css`で外部ファイルを配信
- ファイルが存在しない場合はデフォルトCSSをバイナリから返す

---

## 推奨アプローチのまとめ

1. **バイナリ構成**: 2つのバイナリに分離（安定性重視）
2. **モデル形式**: ONNX形式（配布の簡便さ）
3. **通知方式**: SSE + HTTP POST（リアルタイム性とシンプルさのバランス）
4. **フロントエンド**: ハイブリッド方式（HTMLは組み込み、CSSは別ファイル）

---

## 実装プラン概要

### ディレクトリ構成

```
packages/
├── obs-plugin/           # OBSプラグイン（軽量、オプション）
│   ├── Cargo.toml
│   └── src/
│       └── lib.rs       # obs-websocketへのブリッジ
└── victory-detector-rs/ # メイン実行ファイル
    ├── Cargo.toml
    ├── src/
    │   ├── main.rs
    │   ├── core/
    │   │   ├── state.rs      # StateManager
    │   │   ├── vision.rs     # DetectionResult
    │   │   └── cooldown.rs   # CooldownState
    │   ├── inference/
    │   │   └── predictor.rs  # ONNX推論
    │   ├── server/
    │   │   ├── mod.rs
    │   │   ├── routes.rs
    │   │   └── sse.rs
    │   └── cli.rs
    ├── frontend/
    │   ├── index.html
    │   └── style.css
    └── models/
        └── victory_classifier.onnx
```

### 主要クレート

```toml
[dependencies]
# 非同期ランタイム
tokio = { version = "1", features = ["full"] }

# Webサーバー
axum = "0.7"
tower-http = { version = "0.5", features = ["cors", "fs"] }

# ONNX推論
ort = "2"  # onnxruntime

# 画像処理
image = "0.25"
opencv = { version = "0.92", features = ["imgproc"] }

# OBS連携
obws = "0.11"

# JSON/シリアライゼーション
serde = { version = "1", features = ["derive"] }
serde_json = "1"

# ログ
tracing = "0.1"
tracing-subscriber = "0.3"

# エラーハンドリング
anyhow = "1"
thiserror = "1"

# CLI
clap = { version = "4", features = ["derive"] }

# 時刻
chrono = { version = "0.4", features = ["serde"] }
```

### 実装フェーズ

1. **Phase 1**: プロジェクト構造とコア機能（StateManager、イベントログ）
2. **Phase 2**: ONNX推論とOBS連携
3. **Phase 3**: HTTP API + SSE
4. **Phase 4**: フロントエンド（Vue.js CDN版）
5. **Phase 5**: 学習プログラム（Pythonスクリプト維持 + ONNX変換）
6. **Phase 6**: OBSプラグイン（オプション）
7. **Phase 7**: テスト・ドキュメント

### API設計

```
# SSE（リアルタイム通知）
GET /events -> Stream<Event>

# HTTP API（PoCと互換）
GET /state -> CounterState
GET /history?limit=N -> Vec<Event>
POST /adjust -> CounterState

# フロントエンド
GET /overlay -> HTML
GET /frontend/style.css -> CSS
```

### 配布物

**Windows**:

```
victory-detector-v1.0-windows.zip
├── victory-detector.exe
├── models/
│   └── victory_classifier.onnx
├── frontend/
│   └── style.css
├── README.txt
└── config.toml （オプション）
```
