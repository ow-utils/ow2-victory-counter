# ow2-victory-counter-rs 実装詳細

このドキュメントは開発者向けの実装詳細を記載します。エンドユーザー向けの概要は `docs/specs/ow2-victory-counter-rsアーキテクチャ設計.md` を参照してください。

## 開発環境

### Rust 環境

- **Rust**: 1.70 以上
- **Cargo**: Rust 標準パッケージマネージャー
- **ツールチェーン**: stable

### JavaScript 環境

- **Node.js**: 18.x 以上
- **pnpm**: 8.x 以上（パッケージマネージャー）
- **TypeScript**: 5.x
- **Svelte**: 4.x
- **Vite**: 5.x（ビルドツール）

### インストール

```bash
# Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Node.js（nvmを使用）
nvm install 18
nvm use 18

# pnpm
npm install -g pnpm
```

## リポジトリー構造

```
packages/ow2-victory-counter-rs/
├── src/                          # Rustソースコード
│   ├── main.rs                   # エントリーポイント
│   ├── server/                   # HTTPサーバー
│   │   ├── mod.rs
│   │   ├── routes.rs             # ルーティング
│   │   └── sse.rs                # SSEハンドラー
│   ├── state/                    # StateManager
│   │   ├── mod.rs
│   │   └── manager.rs
│   ├── predictor/                # CNN推論
│   │   ├── mod.rs
│   │   └── onnx.rs
│   ├── capture/                  # 画像取得
│   │   ├── mod.rs
│   │   └── obs.rs
│   └── config.rs                 # 設定
├── frontend/                     # Svelteフロントエンド
│   ├── obs-ui/                   # OBS用UI
│   │   ├── src/
│   │   │   ├── App.svelte
│   │   │   ├── main.ts
│   │   │   └── components/
│   │   ├── public/
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   └── vite.config.ts
│   └── admin-ui/                 # 管理画面UI
│       ├── src/
│       │   ├── App.svelte
│       │   ├── main.ts
│       │   └── components/
│       ├── public/
│       ├── package.json
│       ├── tsconfig.json
│       └── vite.config.ts
├── models/                       # ONNXモデル（開発時）
│   ├── victory_classifier.onnx
│   └── victory_classifier.label_map.json
├── Cargo.toml
├── Cargo.lock
└── README.md
```

## ビルドプロセス

### 開発ビルド

```bash
# 1. フロントエンドビルド
cd frontend/obs-ui
pnpm install
pnpm build  # dist/にHTML/JS/CSS生成

cd ../admin-ui
pnpm install
pnpm build  # dist/にHTML/JS/CSS生成

# 2. Rustビルド（フロントエンド成果物を組み込み）
cd ../..
cargo build

# 3. 実行
cargo run -- \
  --source "OBS ソース名" \
  --model models/victory_classifier.onnx
```

### リリースビルド

```bash
# 1. フロントエンドビルド（プロダクション）
cd frontend/obs-ui
pnpm build --mode production

cd ../admin-ui
pnpm build --mode production

# 2. Rustビルド（最適化）
cd ../..
cargo build --release

# 3. 成果物
# target/release/ow2-victory-detector.exe
```

## コンポーネント実装詳細

### 1. 画像取得・前処理モジュール

**ファイル**: `src/capture/obs.rs`

```rust
use obws::Client as ObsClient;
use opencv::{core::*, imgcodecs::*, imgproc::*};

pub struct OBSCapture {
    client: ObsClient,
    source_name: String,
    width: u32,
    height: u32,
}

impl OBSCapture {
    pub async fn new(host: &str, port: u16, password: &str, source_name: String) -> Result<Self> {
        let client = ObsClient::connect(host, port, Some(password)).await?;
        Ok(Self {
            client,
            source_name,
            width: 1920,
            height: 1080,
        })
    }

    pub async fn capture(&self) -> Result<Mat> {
        // 1. OBS WebSocket経由でスクリーンショット取得
        let response = self.client
            .sources()
            .get_source_screenshot(
                &self.source_name,
                "png",
                Some(self.width),
                Some(self.height),
                None,
            )
            .await?;

        // 2. Base64デコード
        let image_data = response.image_data;
        let base64_data = if image_data.starts_with("data:") {
            image_data.split(',').nth(1).unwrap()
        } else {
            &image_data
        };
        let png_bytes = base64::decode(base64_data)?;

        // 3. PNGデコード
        let np_data = Mat::from_slice(&png_bytes)?;
        let image = imdecode(&np_data, IMREAD_COLOR)?;

        Ok(image)
    }

    pub fn preprocess(&self, image: Mat, crop: (i32, i32, i32, i32)) -> Result<Mat> {
        // 4. クロップ (x, y, width, height)
        let (x, y, w, h) = crop;
        let roi = Rect::new(x, y, w, h);
        let cropped = Mat::roi(&image, roi)?;

        // 5. リサイズ（オプション）
        // let mut resized = Mat::default();
        // resize(&cropped, &mut resized, Size::new(512, 512), 0.0, 0.0, INTER_LINEAR)?;

        Ok(cropped.clone())
    }
}
```

### 2. CNN 推論モジュール

**ファイル**: `src/predictor/onnx.rs`

```rust
use ndarray::{Array, Array4};
use ort::{Session, SessionBuilder, Value};
use opencv::core::Mat;
use std::collections::HashMap;

pub struct VictoryPredictor {
    session: Session,
    label_map: HashMap<usize, String>,
}

#[derive(Debug, Clone)]
pub struct Detection {
    pub outcome: String,
    pub confidence: f32,
    pub predicted_class: String,
}

impl VictoryPredictor {
    pub fn new(model_path: &str, label_map_path: &str) -> Result<Self> {
        // ONNX Sessionの初期化
        let session = SessionBuilder::new()?
            .with_model_from_file(model_path)?;

        // label_map読み込み
        let label_map_json = std::fs::read_to_string(label_map_path)?;
        let label_map: HashMap<usize, String> = serde_json::from_str(&label_map_json)?;

        Ok(Self { session, label_map })
    }

    pub fn predict(&self, image: Mat) -> Result<Detection> {
        // 1. 画像をテンソルに変換 (HWC → CHW, BGR → RGB, 正規化)
        let tensor = self.image_to_tensor(image)?;

        // 2. ONNX Runtime推論
        let outputs = self.session.run(vec![Value::from_array(tensor)?])?;

        // 3. 出力から最大確率のクラスを取得
        let output_tensor = outputs[0].extract_tensor::<f32>()?;
        let probs = output_tensor.view();

        let (class_idx, &confidence) = probs
            .iter()
            .enumerate()
            .max_by(|(_, a), (_, b)| a.partial_cmp(b).unwrap())
            .unwrap();

        // 4. クラスIDをラベルに変換
        let predicted_class = self.label_map
            .get(&class_idx)
            .cloned()
            .unwrap_or_else(|| format!("unknown_{}", class_idx));

        let outcome = self.class_to_outcome(&predicted_class);

        Ok(Detection {
            outcome,
            confidence,
            predicted_class,
        })
    }

    fn image_to_tensor(&self, image: Mat) -> Result<Array4<f32>> {
        // OpenCV Mat (HWC, BGR) → ndarray (CHW, RGB)
        let (height, width) = (image.rows(), image.cols());
        let mut tensor = Array4::<f32>::zeros((1, 3, height as usize, width as usize));

        for y in 0..height {
            for x in 0..width {
                let pixel = image.at_2d::<Vec3b>(y, x)?;
                // BGR → RGB, 0-255 → 0-1
                tensor[[0, 0, y as usize, x as usize]] = pixel[2] as f32 / 255.0;  // R
                tensor[[0, 1, y as usize, x as usize]] = pixel[1] as f32 / 255.0;  // G
                tensor[[0, 2, y as usize, x as usize]] = pixel[0] as f32 / 255.0;  // B
            }
        }

        Ok(tensor)
    }

    fn class_to_outcome(&self, class: &str) -> String {
        match class {
            "victory" | "victory_1" | "victory_2" => "victory".to_string(),
            "defeat" | "defeat_1" | "defeat_2" => "defeat".to_string(),
            "draw" => "draw".to_string(),
            _ => "none".to_string(),
        }
    }
}
```

### 3. StateManager

**ファイル**: `src/state/manager.rs`

```rust
use std::time::{Duration, Instant};
use tokio::sync::broadcast;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum State {
    Ready,
    Cooldown,
    WaitingForNone,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CounterUpdate {
    pub victories: u32,
    pub defeats: u32,
    pub draws: u32,
    pub last_outcome: Option<String>,
    pub timestamp: f64,
}

pub struct StateManager {
    state: State,
    victories: u32,
    defeats: u32,
    draws: u32,
    cooldown_seconds: u64,
    required_consecutive: usize,
    consecutive_detections: Vec<String>,
    last_event_time: Option<Instant>,
    broadcast_tx: broadcast::Sender<CounterUpdate>,
}

impl StateManager {
    pub fn new(cooldown_seconds: u64, required_consecutive: usize) -> Self {
        let (broadcast_tx, _) = broadcast::channel(100);

        Self {
            state: State::Ready,
            victories: 0,
            defeats: 0,
            draws: 0,
            cooldown_seconds,
            required_consecutive,
            consecutive_detections: Vec::new(),
            last_event_time: None,
            broadcast_tx,
        }
    }

    pub fn subscribe(&self) -> broadcast::Receiver<CounterUpdate> {
        self.broadcast_tx.subscribe()
    }

    pub fn record_detection(&mut self, outcome: &str) -> bool {
        match self.state {
            State::Ready => {
                if outcome != "none" {
                    self.consecutive_detections.push(outcome.to_string());

                    if self.consecutive_detections.len() >= self.required_consecutive {
                        // カウント確定
                        self.increment_counter(outcome);
                        self.state = State::Cooldown;
                        self.last_event_time = Some(Instant::now());
                        self.consecutive_detections.clear();

                        // SSE配信
                        self.broadcast_update(Some(outcome.to_string()));
                        return true;
                    }
                } else {
                    self.consecutive_detections.clear();
                }
            }
            State::Cooldown => {
                if let Some(last_time) = self.last_event_time {
                    if last_time.elapsed().as_secs() >= self.cooldown_seconds {
                        if outcome != "none" {
                            self.state = State::WaitingForNone;
                        }
                    }
                }
            }
            State::WaitingForNone => {
                if outcome == "none" {
                    self.state = State::Ready;
                }
            }
        }

        false
    }

    fn increment_counter(&mut self, outcome: &str) {
        match outcome {
            "victory" => self.victories += 1,
            "defeat" => self.defeats += 1,
            "draw" => self.draws += 1,
            _ => {}
        }
    }

    pub fn initialize(&mut self, victories: u32, defeats: u32, draws: u32) {
        self.victories = victories;
        self.defeats = defeats;
        self.draws = draws;
        self.broadcast_update(None);
    }

    pub fn adjust(&mut self, outcome: &str, delta: i32) {
        match outcome {
            "victory" => self.victories = (self.victories as i32 + delta).max(0) as u32,
            "defeat" => self.defeats = (self.defeats as i32 + delta).max(0) as u32,
            "draw" => self.draws = (self.draws as i32 + delta).max(0) as u32,
            _ => {}
        }
        self.broadcast_update(Some(outcome.to_string()));
    }

    fn broadcast_update(&self, last_outcome: Option<String>) {
        let update = CounterUpdate {
            victories: self.victories,
            defeats: self.defeats,
            draws: self.draws,
            last_outcome,
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs_f64(),
        };

        let _ = self.broadcast_tx.send(update);
    }

    pub fn summary(&self) -> CounterUpdate {
        CounterUpdate {
            victories: self.victories,
            defeats: self.defeats,
            draws: self.draws,
            last_outcome: None,
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs_f64(),
        }
    }
}
```

### 4. HTTP サーバー

**ファイル**: `src/server/routes.rs`

```rust
use axum::{
    Router,
    routing::{get, post},
    response::{Html, Response, sse::{Event, Sse}},
    extract::State,
    Json,
    http::StatusCode,
};
use tokio_stream::{wrappers::BroadcastStream, StreamExt};
use std::convert::Infallible;
use std::time::Duration;

#[derive(Clone)]
pub struct AppState {
    pub state_manager: Arc<Mutex<StateManager>>,
}

pub fn app(state: AppState) -> Router {
    Router::new()
        .route("/", get(serve_obs_ui))
        .route("/admin", get(serve_admin_ui))
        .route("/custom.css", get(serve_custom_css))
        .route("/events", get(sse_handler))
        .route("/api/status", get(get_status))
        .route("/api/initialize", post(initialize))
        .route("/api/adjust", post(adjust))
        .with_state(state)
}

async fn serve_obs_ui() -> Html<String> {
    // バイナリー組み込みHTML
    Html(include_str!("../../frontend/obs-ui/dist/index.html").to_string())
}

async fn serve_admin_ui() -> Html<String> {
    // バイナリー組み込みHTML
    Html(include_str!("../../frontend/admin-ui/dist/index.html").to_string())
}

async fn serve_custom_css() -> Result<Response, StatusCode> {
    // 外部ファイル優先
    if let Ok(css) = tokio::fs::read_to_string("templates/custom.css").await {
        return Ok(Response::builder()
            .header("Content-Type", "text/css")
            .body(css.into())
            .unwrap());
    }

    // デフォルトは空CSS
    Ok(Response::builder()
        .header("Content-Type", "text/css")
        .body("".into())
        .unwrap())
}

async fn sse_handler(
    State(state): State<AppState>,
) -> Sse<impl Stream<Item = Result<Event, Infallible>>> {
    let manager = state.state_manager.lock().await;
    let rx = manager.subscribe();
    drop(manager);

    let stream = BroadcastStream::new(rx)
        .map(|result| {
            result
                .map(|update| {
                    Event::default()
                        .event("counter-update")
                        .json_data(&update)
                        .unwrap()
                })
                .map_err(|_| Infallible)
        });

    Sse::new(stream).keep_alive(
        axum::response::sse::KeepAlive::new()
            .interval(Duration::from_secs(15))
            .text("keep-alive"),
    )
}

async fn get_status(State(state): State<AppState>) -> Json<CounterUpdate> {
    let manager = state.state_manager.lock().await;
    Json(manager.summary())
}

#[derive(Deserialize)]
struct InitializeRequest {
    victories: u32,
    defeats: u32,
    draws: u32,
}

async fn initialize(
    State(state): State<AppState>,
    Json(data): Json<InitializeRequest>,
) -> Json<CounterUpdate> {
    let mut manager = state.state_manager.lock().await;
    manager.initialize(data.victories, data.defeats, data.draws);
    Json(manager.summary())
}

#[derive(Deserialize)]
struct AdjustRequest {
    outcome: String,
    delta: i32,
}

async fn adjust(
    State(state): State<AppState>,
    Json(data): Json<AdjustRequest>,
) -> Json<CounterUpdate> {
    let mut manager = state.state_manager.lock().await;
    manager.adjust(&data.outcome, data.delta);
    Json(manager.summary())
}
```

### 5. OBS 用 UI (Svelte)

**ファイル**: `frontend/obs-ui/src/App.svelte`

```svelte
<script lang="ts">
  import { tweened } from 'svelte/motion';
  import { cubicOut } from 'svelte/easing';
  import { onMount } from 'svelte';

  let victories = tweened(0, { duration: 1000, easing: cubicOut });
  let defeats = tweened(0, { duration: 1000, easing: cubicOut });
  let draws = tweened(0, { duration: 1000, easing: cubicOut });

  onMount(() => {
    // SSE接続
    const eventSource = new EventSource('/events');

    eventSource.addEventListener('counter-update', (e: MessageEvent) => {
      const data = JSON.parse(e.data);
      victories.set(data.victories);
      defeats.set(data.defeats);
      draws.set(data.draws);
    });

    eventSource.onerror = () => {
      console.error('SSE connection error, reconnecting...');
    };
  });
</script>

<div class="counter-grid">
  <div class="victory">
    <div class="label">Victory</div>
    <div class="value">{Math.floor($victories)}</div>
  </div>
  <div class="defeat">
    <div class="label">Defeat</div>
    <div class="value">{Math.floor($defeats)}</div>
  </div>
  <div class="draw">
    <div class="label">Draw</div>
    <div class="value">{Math.floor($draws)}</div>
  </div>
</div>

<style>
  :global(body) {
    margin: 0;
    padding: 0;
    background: transparent;
  }

  .counter-grid {
    --victory-color: #4caf50;
    --defeat-color: #f44336;
    --draw-color: #ff9800;
    --font-size: 64px;
    --gap: 20px;

    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: var(--gap);
    padding: 40px;
    font-family: Arial, sans-serif;
  }

  .victory { color: var(--victory-color); }
  .defeat { color: var(--defeat-color); }
  .draw { color: var(--draw-color); }

  .label {
    font-size: calc(var(--font-size) * 0.5);
    opacity: 0.8;
  }

  .value {
    font-size: var(--font-size);
    font-weight: bold;
    text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.9);
  }
</style>
```

### 6. 管理画面 UI (Svelte)

**ファイル**: `frontend/admin-ui/src/App.svelte`

```svelte
<script lang="ts">
  import { tweened } from 'svelte/motion';
  import { cubicOut } from 'svelte/easing';
  import { onMount } from 'svelte';

  let victories = tweened(0, { duration: 1000, easing: cubicOut });
  let defeats = tweened(0, { duration: 1000, easing: cubicOut });
  let draws = tweened(0, { duration: 1000, easing: cubicOut });

  onMount(async () => {
    // localStorage から復元
    const saved = localStorage.getItem('counter_state');
    if (saved) {
      const data = JSON.parse(saved);
      victories.set(data.victories, { duration: 0 });
      defeats.set(data.defeats, { duration: 0 });
      draws.set(data.draws, { duration: 0 });

      // サーバーに初期化
      await fetch('/api/initialize', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });
    }

    // SSE接続
    const eventSource = new EventSource('/events');
    eventSource.addEventListener('counter-update', (e: MessageEvent) => {
      const data = JSON.parse(e.data);
      victories.set(data.victories);
      defeats.set(data.defeats);
      draws.set(data.draws);

      // localStorage保存
      localStorage.setItem('counter_state', JSON.stringify({
        victories: data.victories,
        defeats: data.defeats,
        draws: data.draws,
      }));
    });
  });

  async function adjust(outcome: string, delta: number) {
    await fetch('/api/adjust', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ outcome, delta }),
    });
  }

  async function reset() {
    if (confirm('本当にリセットしますか？')) {
      await fetch('/api/initialize', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ victories: 0, defeats: 0, draws: 0 }),
      });
      localStorage.removeItem('counter_state');
    }
  }
</script>

<main>
  <h1>Victory Counter 管理画面</h1>

  <div class="counter-grid">
    <div class="counter-item victory">
      <div class="label">Victory</div>
      <div class="value">{Math.floor($victories)}</div>
      <div class="controls">
        <button on:click={() => adjust('victory', 1)}>+</button>
        <button on:click={() => adjust('victory', -1)}>-</button>
      </div>
    </div>

    <div class="counter-item defeat">
      <div class="label">Defeat</div>
      <div class="value">{Math.floor($defeats)}</div>
      <div class="controls">
        <button on:click={() => adjust('defeat', 1)}>+</button>
        <button on:click={() => adjust('defeat', -1)}>-</button>
      </div>
    </div>

    <div class="counter-item draw">
      <div class="label">Draw</div>
      <div class="value">{Math.floor($draws)}</div>
      <div class="controls">
        <button on:click={() => adjust('draw', 1)}>+</button>
        <button on:click={() => adjust('draw', -1)}>-</button>
      </div>
    </div>
  </div>

  <div class="actions">
    <button class="reset-btn" on:click={reset}>リセット</button>
  </div>
</main>

<style>
  main {
    max-width: 800px;
    margin: 0 auto;
    padding: 40px 20px;
    font-family: Arial, sans-serif;
  }

  h1 {
    text-align: center;
    color: #333;
  }

  .counter-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px;
    margin: 40px 0;
  }

  .counter-item {
    text-align: center;
    padding: 20px;
    border-radius: 8px;
    background: #f5f5f5;
  }

  .victory { border-left: 4px solid #4caf50; }
  .defeat { border-left: 4px solid #f44336; }
  .draw { border-left: 4px solid #ff9800; }

  .label {
    font-size: 18px;
    color: #666;
    margin-bottom: 10px;
  }

  .value {
    font-size: 48px;
    font-weight: bold;
    margin: 10px 0;
  }

  .controls {
    display: flex;
    gap: 10px;
    justify-content: center;
  }

  button {
    padding: 8px 20px;
    font-size: 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    background: #2196f3;
    color: white;
  }

  button:hover {
    background: #1976d2;
  }

  .actions {
    text-align: center;
    margin-top: 40px;
  }

  .reset-btn {
    background: #f44336;
  }

  .reset-btn:hover {
    background: #d32f2f;
  }
</style>
```

## ui-config.json 仕様

**ファイル**: `config/ui-config.json`

```json
{
  "components": {
    "victory": true,
    "defeat": true,
    "draw": true
  },
  "layout": {
    "orientation": "horizontal",
    "fontSize": 64,
    "gap": 20
  },
  "colors": {
    "victory": "#4caf50",
    "defeat": "#f44336",
    "draw": "#ff9800"
  }
}
```

**読み込み方法（Svelte）**:

```typescript
import { onMount } from "svelte";

let config = {
  components: { victory: true, defeat: true, draw: true },
  layout: { orientation: "horizontal", fontSize: 64, gap: 20 },
  colors: { victory: "#4caf50", defeat: "#f44336", draw: "#ff9800" },
};

onMount(async () => {
  try {
    const response = await fetch("/config/ui-config.json");
    if (response.ok) {
      config = await response.json();
    }
  } catch (e) {
    console.warn("Failed to load ui-config.json, using defaults");
  }
});
```

## ONNX 変換スクリプト

**ファイル**: `packages/obs-victory-counter/victory-detector/scripts/convert_to_onnx.py`

```python
import argparse
import json
import torch
import onnxruntime as ort
import numpy as np
from pathlib import Path
from victory_detector.training.model import VictoryClassifier

def convert_to_onnx(
    input_path: Path,
    output_path: Path,
    opset_version: int = 14
):
    """PyTorchモデルをONNX形式に変換"""

    # 1. PyTorchモデル読み込み
    print(f"[1/4] PyTorchモデル読み込み: {input_path}")
    checkpoint = torch.load(input_path, map_location='cpu')
    num_classes = len(checkpoint['label_map'])

    model = VictoryClassifier(num_classes=num_classes)
    model.load_state_dict(checkpoint['model_state_dict'])
    model.eval()

    # 2. ダミー入力作成（クロップ後の画像サイズ）
    print("[2/4] ダミー入力作成: (1, 3, 550, 995)")
    dummy_input = torch.randn(1, 3, 550, 995)

    # 3. ONNX変換
    print(f"[3/4] ONNX変換中...")
    output_path.parent.mkdir(parents=True, exist_ok=True)

    torch.onnx.export(
        model,
        dummy_input,
        str(output_path),
        export_params=True,
        opset_version=opset_version,
        do_constant_folding=True,
        input_names=['input'],
        output_names=['output'],
        dynamic_axes={
            'input': {0: 'batch_size'},
            'output': {0: 'batch_size'}
        }
    )

    # 4. label_map保存（別ファイル）
    label_map_path = output_path.with_suffix('.label_map.json')
    print(f"[4/4] ラベルマップ保存: {label_map_path}")
    with open(label_map_path, 'w') as f:
        json.dump(checkpoint['label_map'], f, indent=2)

    print(f"\n✅ 変換完了:")
    print(f"  - ONNXモデル: {output_path}")
    print(f"  - ラベルマップ: {label_map_path}")

    # 精度検証
    verify_conversion(model, output_path, dummy_input)

def verify_conversion(pytorch_model, onnx_path: Path, dummy_input):
    """変換後の精度検証"""
    print("\n[検証] 変換精度チェック中...")

    # PyTorch推論
    with torch.no_grad():
        pytorch_output = pytorch_model(dummy_input).numpy()

    # ONNX Runtime推論
    session = ort.InferenceSession(str(onnx_path))
    onnx_output = session.run(None, {'input': dummy_input.numpy()})[0]

    # 誤差計算
    max_diff = np.abs(pytorch_output - onnx_output).max()
    mean_diff = np.abs(pytorch_output - onnx_output).mean()

    print(f"  - 最大誤差: {max_diff:.2e}")
    print(f"  - 平均誤差: {mean_diff:.2e}")

    if max_diff < 1e-5:
        print("  ✅ 変換精度良好（誤差 < 1e-5）")
    elif max_diff < 1e-4:
        print("  ⚠️  変換精度やや低い（誤差 < 1e-4）")
    else:
        print("  ❌ 変換精度不足（誤差 >= 1e-4）")
        raise ValueError("ONNX変換の精度が低すぎます")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--input",
        type=Path,
        default=Path("artifacts/models/victory_classifier.pth"),
        help="入力PyTorchモデル (.pth)"
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("models/victory_classifier.onnx"),
        help="出力ONNXモデル (.onnx)"
    )
    parser.add_argument(
        "--opset-version",
        type=int,
        default=14,
        help="ONNX opsetバージョン"
    )

    args = parser.parse_args()
    convert_to_onnx(args.input, args.output, args.opset_version)
```

## デバッグ方法

### Rust側のログ

```rust
use tracing::{info, warn, error};

// ログ初期化
tracing_subscriber::fmt()
    .with_max_level(tracing::Level::DEBUG)
    .init();

// 使用例
info!("Server started on http://127.0.0.1:3000");
warn!("Detection confidence low: {}", confidence);
error!("Failed to capture image: {:?}", err);
```

### フロントエンド側のデバッグ

```javascript
// ブラウザーコンソールでSSEイベント確認
const eventSource = new EventSource("/events");
eventSource.addEventListener("counter-update", (e) => {
  console.log("SSE Event:", JSON.parse(e.data));
});

// localStorage確認
console.log(localStorage.getItem("counter_state"));
```

### curl でのテスト

```bash
# 状態取得
curl http://localhost:3000/api/status

# 初期化
curl -X POST http://localhost:3000/api/initialize \
  -H "Content-Type: application/json" \
  -d '{"victories": 10, "defeats": 5, "draws": 2}'

# 調整
curl -X POST http://localhost:3000/api/adjust \
  -H "Content-Type: application/json" \
  -d '{"outcome": "victory", "delta": 1}'
```

## トラブルシューティング

### ONNX Runtime エラー

```
Error: ONNX Runtime error: No suitable execution provider found
```

**解決策**: ONNX Runtime の CPU バックエンドをインストール

```bash
cargo add ort --features download-binaries
```

### フロントエンドビルドエラー

```
Module not found: Error: Can't resolve 'svelte/motion'
```

**解決策**: 依存関係を再インストール

```bash
cd frontend/obs-ui
rm -rf node_modules pnpm-lock.yaml
pnpm install
```

### OBS WebSocket 接続エラー

```
Error: Failed to connect to OBS WebSocket
```

**解決策**:

1. OBS で WebSocket を有効化（ツール → WebSocket サーバー設定）
2. ポート番号とパスワードを確認
3. ファイアウォール設定を確認
